# Frequency Counter

이 패턴은 객체나 집합(set)을 사용하여 값 또는 값의 빈도수를 수집합니다.
이는 종종 중첩된 루프 또는 배열/문자열의 O(N^2) 연산을 피할 수 있습니다.

즉, 이 패턴은 자료 구조를 적절하게 활용하여 연산 속도를 향상시키는 기법입니다.

예를 들어, 배열 또는 문자열에서 반복적으로 값을 찾아야 할 때, 객체나 집합(set)을 활용하여 값을 수집하면 중복 검사나 비효율적인 연산을 피할 수 있어서 성능을 개선할 수 있습니다.

## AN EXAMPLE

### same 함수 :

1. 함수 same를 정의한다.
2. arr1과 arr2의 길이가 같은지 확인한다. 만약 길이가 다르면 false를 반환하고 함수를 종료한다.
3. arr1의 모든 요소에 대해 제곱값을 arr2에서 찾아본다.
4. 만약 제곱값을 찾을 수 없다면 false를 반환하고 함수를 종료한다.
5. 만약 제곱값을 찾았다면 arr2에서 해당 요소를 제거한다.
6. arr1의 모든 요소를 순회한 후에도 문제가 없으면 true를 반환한다.

### refactor same1 함수 :

1. 두 개의 배열을 비교하여, 길이가 다르면 false를 반환한다.

2. 빈 객체인 frequencyCounter1과 frequencyCounter2를 선언한다.

3. arr1의 각 요소를 for...of문으로 반복하며, frequencyCounter1 객체에 해당 요소의 값을 key로 하고, 동일한 요소의 개수를 value로 하는 key-value pair를 추가한다.

4. arr2의 각 요소도 for...of문으로 반복하며, frequencyCounter2 객체에 해당 요소의 값을 key로 하고, 동일한 요소의 개수를 value로 하는 key-value pair를 추가한다.

5. frequencyCounter1의 모든 key-value pair를 for...in문으로 반복하며, key의 제곱값이 frequencyCounter2의 key로 존재하지 않으면 false를 반환한다.

6. frequencyCounter2의 key로 해당 key의 제곱값이 존재할 때, frequencyCounter2[key의 제곱값]의 값과 frequencyCounter1[key]의 값이 다르면 false를 반환한다.

7. 모든 요소에 대한 비교가 완료되면, true를 반환한다.

### 두 함수 비교

두 함수 모두 두 개의 배열이 주어졌을 때, 두 번째 배열이 첫 번째 배열의 요소들의 제곱값으로 이루어진 배열인지 확인하는 함수입니다. 하지만 첫 번째 함수는 배열을 순회하며 인덱스를 찾는 방식으로 동작하는 반면, 두 번째 함수는 각 요소들의 등장 빈도수를 객체에 저장하여 비교합니다.

첫 번째 함수는 O(n^2)의 시간복잡도를 갖는 반면, 두 번째 함수는 O(n)의 시간복잡도를 갖기 때문에 두 번째 함수가 더욱 효율적인 방식으로 동작합니다. 또한 두 번째 함수는 중첩 for loop를 사용하지 않기 때문에 코드의 가독성과 유지보수가 더욱 용이합니다.
